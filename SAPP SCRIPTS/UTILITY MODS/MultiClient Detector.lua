--[[
--=====================================================================================================--
Script Name: Multiclient Detector.lua, for SAPP (PC & CE)
Description: This script will detect whether a player is using multi-client and retrieve an overall probability score.
             The probability score is based on a number of factors that are analyzed.
             Unfortunately, this script will never be 100% accurate but provides a good indication.

Copyright (c) 2022, Jericho Crosby <jericho.crosby227@gmail.com>
Notice: You can use this script subject to the following conditions:
https://github.com/Chalwk77/HALO-SCRIPT-PROJECTS/blob/master/LICENSE
--=====================================================================================================--
]]--

local Multiclient = {

    -- File containing client information (ip, name, port, hash):
    -- This file is automatically generated and will be located in the same directory as mapcycle.txt.
    file = 'multiclients.json',


    -- Players with common ports are likely not using a MultiClient.
    -- Though, the generic multiclient and Chimera will generate ports between 800-0xFFFF (65535)
    -- Min Range, Max Range
    common_ports = {
        { 2300, 2400 },
        -- repeat the structure to add more port ranges
    },


    -- If the port is NOT common and is within a 4 digit range, what range should be considered as suspicious?
    min_range = 2401,
    max_range = 65535,

    -- Query Command Syntax: /command [player id]
    command = 'mc',

    -- Command Output:
    output_message = '$name - MultiClient Probability: $probability% chance.',

    -- Minimum permission needed to execute query command:
    permission_level = 4,

    -- This is a list of all known pirated hashes:
    known_pirated_hashes = {
        ['388e89e69b4cc08b3441f25959f74103'] = true,
        ['81f9c914b3402c2702a12dc1405247ee'] = true,
        ['c939c09426f69c4843ff75ae704bf426'] = true,
        ['13dbf72b3c21c5235c47e405dd6e092d'] = true,
        ['29a29f3659a221351ed3d6f8355b2200'] = true,
        ['d72b3f33bfb7266a8d0f13b37c62fddb'] = true,
        ['76b9b8db9ae6b6cacdd59770a18fc1d5'] = true,
        ['55d368354b5021e7dd5d3d1525a4ab82'] = true,
        ['d41d8cd98f00b204e9800998ecf8427e'] = true,
        ['c702226e783ea7e091c0bb44c2d0ec64'] = true,
        ['f443106bd82fd6f3c22ba2df7c5e4094'] = true,
        ['10440b462f6cbc3160c6280c2734f184'] = true,
        ['3d5cd27b3fa487b040043273fa00f51b'] = true,
        ['b661a51d4ccf44f5da2869b0055563cb'] = true,
        ['740da6bafb23c2fbdc5140b5d320edb1'] = true,
        ['7503dad2a08026fc4b6cfb32a940cfe0'] = true,
        ['4486253cba68da6786359e7ff2c7b467'] = true,
        ['f1d7c0018e1648d7d48f257dc35e9660'] = true,
        ['40da66d41e9c79172a84eef745739521'] = true,
        ['2863ab7e0e7371f9a6b3f0440c06c560'] = true,
        ['34146dc35d583f2b34693a83469fac2a'] = true,
        ['b315d022891afedf2e6bc7e5aaf2d357'] = true,
        ['63bf3d5a51b292cd0702135f6f566bd1'] = true,
        ['6891d0a75336a75f9d03bb5e51a53095'] = true,
        ['325a53c37324e4adb484d7a9c6741314'] = true,
        ['0e3c41078d06f7f502e4bb5bd886772a'] = true,
        ['fc65cda372eeb75fc1a2e7d19e91a86f'] = true,
        ['f35309a653ae6243dab90c203fa50000'] = true,
        ['50bbef5ebf4e0393016d129a545bd09d'] = true,
        ['a77ee0be91bd38a0635b65991bc4b686'] = true,
        ['3126fab3615a94119d5fe9eead1e88c1'] = true
    }
}

local players = {}
local open = io.open
local json = loadfile('./json.lua')()

api_version = '1.12.0.0'

function Multiclient:LoadDB()

    local content = ''
    local file = open(self.dir, 'r')
    if (file) then
        content = file:read('*all')
        file:close()
    end

    local data = json:decode(content)
    if (not data) then
        data = {}
        self:Update(data)
    end

    return data
end

function Multiclient:Update()
    local file = open(self.dir, 'w')
    if (file) then
        file:write(json:encode_pretty(self.db))
        file:close()
    end
end

function Multiclient:NewPlayer(o)

    setmetatable(o, self)
    self.__index = self

    o.probability = 0

    self.db[o.ip] = self.db[o.ip] or { hash = o.hash, port = o.port }
    self.db[o.ip].name = o.name -- update name


    self:Update()
    o:SetProbability()

    return o
end

function Multiclient:SetProbability()

    if (not self.known_pirated_hashes[self.hash]) then
        self.probability = self.probability + 1
        --print('hash is not pirated')

        local db = self.db[self.ip]
        if (db.port ~= self.port) then
            self.probability = self.probability + 1
            --print('port does not match last used port')
        end
        if (db.hash ~= self.hash) then
            self.probability = self.probability + 1
            --print('hash does not match last used hash')
        end

        local common
        for _, v in ipairs(self.common_ports) do
            local min, max = v[1], v[2]
            local port = tonumber(self.port)
            if (port >= min and port <= max) then
                common = true
                --print('port is common')
            end
        end

        if (not common) then
            self.probability = self.probability + 1
            --print('port is not common')
            if (self.port:len() > 4) then
                self.probability = self.probability + 1
                --print('port > 4 digits')
            elseif (tonumber(self.port) >= self.min_range and tonumber(self.port) <= self.max_range) then
                self.probability = self.probability + 1
                --print('port >= min_range, <= max_range')
            end
        end
    end

    self.probability = (self.probability / 5) * 100

    -- Debugging --
    --local prob = self.probability
    --local msg = self.output_message:gsub('$name', self.name):gsub('$probability', prob)
    --cprint(msg)
end

function OnScriptLoad()

    local dir = read_string(read_dword(sig_scan('68??????008D54245468') + 0x1))
    Multiclient.dir = dir .. '\\sapp\\' .. Multiclient.file
    Multiclient.db = Multiclient:LoadDB()

    register_callback(cb['EVENT_JOIN'], 'OnJoin')
    register_callback(cb['EVENT_LEAVE'], 'OnQuit')
    register_callback(cb['EVENT_GAME_END'], 'OnEnd')
    register_callback(cb['EVENT_GAME_START'], 'OnStart')
    register_callback(cb['EVENT_COMMAND'], 'OnCommand')

    OnStart()
end

function OnStart()
    if (get_var(0, '$gt') ~= 'n/a') then
        players = {}
        for i = 1, 16 do
            if player_present(i) then
                OnJoin(i)
            end
        end
    end
end

function OnEnd()
    Multiclient:Update()
end

function OnJoin(P)

    local ip = get_var(P, '$ip')
    local port = ip:match(':(.*)')

    players[P] = Multiclient:NewPlayer({
        pid = P,
        port = port,
        name = get_var(P, '$name'),
        hash = get_var(P, '$hash'),
        ip = ip:match('%d+.%d+.%d+.%d+')
    })
end

function OnQuit(P)

    -- update db with this players last known port/hash:
    local p = players[P]
    local db = Multiclient.db[p.ip]

    if (db.hash ~= p.hash or db.port ~= p.port) then
        Multiclient.db[p.ip] = { hash = p.hash, port = p.port }
        Multiclient:Update()
    end
end

local function CMDSplit(s)
    local t = { }
    for arg in s:gmatch('([^%s]+)') do
        t[#t + 1] = arg:lower()
    end
    return t
end

local function HasPermission(P)
    local lvl = tonumber(get_var(P, '$lvl'))
    return (P == 0 or lvl >= Multiclient.permission_level)
end

local function Respond(P, S)
    return (P == 0 and cprint(S) or rprint(P, S))
end

function OnCommand(P, CMD)

    local args = CMDSplit(CMD)
    if (#args > 0 and args[1] == Multiclient.command) then
        if (not HasPermission(P)) then
            Respond(P, 'Insufficient Permission')
        elseif (args[2]) then

            local target = args[2]:match('%d+')
            local player = players[tonumber(target)]

            if (player) then
                local prob = player.probability
                local msg = Multiclient.output_message
                msg = msg:gsub('$name', player.name):gsub('$probability', prob)
                Respond(P, msg)
            else
                Respond(P, 'Invalid Player.')
            end
        end
        return false
    end
end

function OnScriptUnload()
    -- N/A
end